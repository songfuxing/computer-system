## 汇编指令对程序的控制

gcc编译
```
gcc -Og -S mstore.c
```
### 整数寄存器
不同程序的运算都是在同样的寄存器当中。<br>
CPU包含一组16个存储64位值的**通用目的寄存器**。用来计算时存储数值和地址。名字以%r开头，具体参看书中P120。
## 指令
### 数据传送指令
mov
```
movl $0x4050, %eax， ## Immediate-> Register, 4 bytes
movb (%rdi, %rcx), %al ## Memory -> Register, 1bitye
```
第一个是源操作数，第二个是目的操作数。其中(%rdi)表示寄存器中保存的是地址，从改地址拿到数值。与c的联系：（1）、c中的指针其实就是地址，使用指针就是将地址存放到寄存器中，然后在内存中使用这个寄存器。（2）、局部变量、常量保存在寄存器中，而不是内存中。
### 栈
栈的实现可以用数组，从数组的一端（栈顶）插入和删除数据。<br>
push:栈寄存器%rsp减8，向下延伸，栈底在高地址位，往低地址位增加。将栈寄存器所在的物理地址，写上新的数据的地址。<br>
%rsp寄存器指向当前栈顶的位置（内存地址），写进来的数据保存在内存中。所以pop之后可以读取到之前位置的数据。
### 算术、逻辑运算
加载有效地址leaq
```
leaq (%rdi, %rsi, 4), %rax #x+4*y
```
一元操作incq,decq,自己即使源有是目的
```
incq 16(%rax)
```
二元操作，add subq
##  控制
### 条件码寄存器
描述最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。
### swith
使用跳转表实现多重分支跳转
## 过程
- 控制的传递：（1）保存返回值地址（2）程序计数器转移到子函数的开始位置
- 参数的传递
- 先分配内存，然后释放内存（局部变量）

### 控制传递
（1）保存调用函数的返回地址<br>
将返回值push入栈：%rsp地址增加，*%rsp=调用函数的返回值<br>

 (2) pc设置为被调用函数的入口地址<br>
 执行被调用函数

 (3) 遇到ret指令返回
 返回值存储在寄存器%rax中

### 数据传递
（1）寄存器传参
当参数个数小于6个的时候，直接使用寄存器传递
（2）栈传参
在下面这几种情况下，会把数据存到栈上，通过%rsp的偏移，把数据存储到栈上的不同位置处：
- 寄存器不足存放所有数据，参数个数大于6
- 对一个局部变量使用&取地址运算符
- 某些局部变量是数组或者对象（struct），需要通过引用被访问到

递归调用：通过栈帧的机制，每个过程调用都有自己的私有空间，可以方便的实现递归调用。

## 数组
### 指针运算
c允许指针运算，计算出来的值会根据改指针引用的数据类型大小进行伸缩。数组A[n+i]等价与指针操作*(A+i)


操作符* 和&：
- \* 操作符<br>
产生间接引用指针，如果expr是一个地址表达式，*expr表示改地址处保存的值
- &操作符
产生指针，如果expr是一个对象表达书，&expr表示指向该对象的地址的指针

expr等价与*&expr
